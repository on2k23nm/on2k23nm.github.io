<!DOCTYPE html>
<html lang=" en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Observer Pattern (Case Study): Event Notifications with Pluggable Subscribers</title>
    
    <meta name="description" content="C++ Observer Pattern notes and case study: Stock Market Ticker.">
    

    <link rel="canonical" href="https://on2k23nm.github.io/design-patterns/2026/02/11/Design-Patterns-Observer.html">

    <link rel="shortcut icon" href="/favicon.ico">

    <meta property="og:title" content="Observer Pattern (Case Study): Event Notifications with Pluggable Subscribers">
    <meta property="og:description" content="C++ Observer Pattern notes and case study: Stock Market Ticker.">
    <meta property="og:url" content="https://on2k23nm.github.io/design-patterns/2026/02/11/Design-Patterns-Observer.html">
    <meta property="og:site_name" content="Hack. Crash. Transcend."><meta property="og:type" content="article">
    <meta property="article:published_time" content="2026-02-11T09:00:00+05:30"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Observer Pattern (Case Study): Event Notifications with Pluggable Subscribers">
    <meta name="twitter:description" content="C++ Observer Pattern notes and case study: Stock Market Ticker."><link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/subscription.css">

    <!-- Your stylesheet -->
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/subscription.css">

    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4252008174002764"
        crossorigin="anonymous"></script>

    <meta name="google-site-verification" content="H0Tf6h_kdL03qvRv7KtC4i456PObcGwDPCxeiKFoll4" />

    
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    

    
    <style>
        .mermaid {
            width: 125%;
            margin-left: -12.5%;
            text-align: center;
            margin-top: 2rem;
            margin-bottom: 2rem;
        }

        @media screen and (max-width: 800px) {
            .mermaid {
                width: 100%;
                margin-left: 0;
            }
        }
    </style>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true });
        window.addEventListener('load', function () {
            // Find all blocks marked as mermaid and convert them for mermaid.js to process
            const blocks = document.querySelectorAll('pre code.language-mermaid');
            blocks.forEach((block, i) => {
                const pre = block.parentElement;
                const container = document.createElement('div');
                container.className = 'mermaid';
                container.id = `mermaid-${i}`;
                container.textContent = block.textContent;
                pre.parentNode.replaceChild(container, pre);
            });
            mermaid.run();
        });
    </script>
    

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://on2k23nm.github.io/design-patterns/2026/02/11/Design-Patterns-Observer.html"
      },
      "headline": "Observer Pattern (Case Study): Event Notifications with Pluggable Subscribers",
      
      "datePublished": "2026-02-11T09:00:00+05:30",
      "dateModified": "2026-02-11T09:00:00+05:30",
      "author": {
        "@type": "Person",
        "name": "Your Name"
      },
       "publisher": {
        "@type": "Organization",
        "name": "Hack. Crash. Transcend.",
        "logo": {
          "@type": "ImageObject",
          "url": "https://on2k23nm.github.io/assets/images/logo.png"
        }
      },
      "description": "C++ Observer Pattern notes and case study: Stock Market Ticker."
      
    }
    </script>

</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-DTMB098MDX"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-DTMB098MDX');
</script>

<body>
    <header class="site-header">
        <div class="wrapper">
            <a class="site-title" href="/">Hack. Crash. Transcend.</a>
            <nav class="site-nav">
  <a class="page-link" href="/">Home</a>
  <a class="page-link" href="/about/">About</a>
</nav>

        </div>
    </header>

    <main class="page-content" aria-label="Content">
        <div class="wrapper">
            <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
                <header class="post-header">
                    <h1 class="post-title" itemprop="name headline">Observer Pattern (Case Study): Event Notifications with Pluggable Subscribers</h1>

                    <p class="post-meta">
                        <time datetime="2026-02-11T09:00:00+05:30" itemprop="datePublished">
                            üìÖ February 11, 2026
                        </time>
                        &nbsp;
                        ‚è±Ô∏è 13-minute read
                    </p>
                </header>

                <!-- 
                <div class="post-tags">
                    
                    <span class="tag">Design Patterns</span>
                    
                    <span class="tag">cpp</span>
                    
                </div>
                 -->
                
                <div class="post-tags">
                    <a class="tag" href="/tags/design-patterns">Design Patterns</a>
                    <a class="tag" href="/tags/cpp">cpp</a>
                    
                </div>
                
                <div class="post-content" itemprop="articleBody">
                    <h3 id="problem-statement-stock-price-ticker-with-multiple-consumers"><strong>Problem statement: Stock Price Ticker with Multiple Consumers</strong></h3>

<p>You‚Äôre building a small ‚Äúmarket data‚Äù module, that receives live stock price updates (ticks) and needs to notify various parts of the system in real-time. The consumers include:</p>
<ol>
  <li>A UI component that displays the latest price for each stock.</li>
  <li>An alert engine that triggers rules like ‚Äúnotify me if AAPL crosses $150.‚Äù</li>
  <li>A risk monitor that recalculates exposure based on the latest prices.</li>
  <li>An audit logger that writes an immutable log entry for every tick.</li>
</ol>

<p>A <code class="language-plaintext highlighter-rouge">PriceFeed</code> receives live ticks: <code class="language-plaintext highlighter-rouge">(symbol, price, timestamp)</code>. Each tick must be broadcast to all active consumers immediately. Consumers can come and go at runtime (e.g., UI opens/closes, alert rules enabled/disabled). The PriceFeed should not need to know about the specific consumers or how many there are.</p>

<p>Multiple independent parts of the system need to react immediately. The PriceFeed <strong>should not be</strong> tightly coupled to any specific consumer. We want a design that allows us to add new consumers without modifying the PriceFeed code.</p>

<p><strong>Input</strong>: A stream of stock price ticks (symbol, price, timestamp).  <br />
<strong>Output</strong>: Real-time notifications to multiple independent consumers (UI, alerts, risk, logging) whenever a new tick arrives.</p>

<h4 id="the-requirements-can-be-summarized-as">The requirements can be summarized as:</h4>

<ul>
  <li>When a new tick arrives, all active consumers must be notified with minimal latency.</li>
  <li>Consumers can come and go, so the system must support dynamic subscription and unsubscription at runtime.</li>
  <li>The PriceFeed should be decoupled from the consumers, adhering to the Open-Closed Principle. Adding new consumers should not require changes to the PriceFeed code.</li>
  <li>The design should be efficient and scalable, capable of handling a high volume of ticks without significant performance degradation.</li>
  <li>UI subscribes when a screen opens, unsubscribes when it closes. This is a common pattern for temporary consumers that only care about updates while active.</li>
  <li>Alert rules may be enabled/disabled at runtime</li>
  <li>Logger might be swapped (file vs Kafka) without touching PriceFeed code</li>
</ul>

<h3 id="naive-approach-direct-coupling"><strong>Naive approach: Direct Coupling</strong></h3>

<p>A first attempt usually looks like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This is a tightly coupled design and violates the Open-Closed Principle</span>
<span class="k">class</span> <span class="nc">PriceFeed</span> <span class="p">{</span>
    <span class="c1">// Direct references to all consumers</span>
    <span class="n">UiTicker</span><span class="o">*</span> <span class="n">ui</span><span class="p">;</span>
    <span class="n">AlertEngine</span><span class="o">*</span> <span class="n">alerts</span><span class="p">;</span>
    <span class="n">RiskMonitor</span><span class="o">*</span> <span class="n">risk</span><span class="p">;</span>
    <span class="n">Logger</span><span class="o">*</span> <span class="n">logger</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="c1">// This method is called whenever a new tick arrives</span>
    <span class="kt">void</span> <span class="n">onNewTick</span><span class="p">(</span><span class="k">const</span> <span class="n">Tick</span><span class="o">&amp;</span> <span class="n">tick</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ui</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">tick</span><span class="p">);</span> 
        <span class="n">alerts</span><span class="o">-&gt;</span><span class="n">on_tick</span><span class="p">(</span><span class="n">tick</span><span class="p">);</span>
        <span class="n">risk</span><span class="o">-&gt;</span><span class="n">on_tick</span><span class="p">(</span><span class="n">tick</span><span class="p">);</span>
        <span class="n">logger</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">tick</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Methods to set the consumers (not ideal)</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Here, the <code class="language-plaintext highlighter-rouge">PriceFeed</code> class has direct references to all the consumers. Whenever a new tick arrives, it explicitly calls each consumer‚Äôs update method. This design has several issues:</p>
<ol>
  <li><strong>Tight Coupling</strong>: <code class="language-plaintext highlighter-rouge">PriceFeed</code> is now tightly coupled to specific consumer classes. If we want to add a new consumer, we have to modify <code class="language-plaintext highlighter-rouge">PriceFeed</code>, which violates the Open-Closed Principle.</li>
  <li><strong>Growing Dependency List</strong>: As we add more consumers, <code class="language-plaintext highlighter-rouge">PriceFeed</code> becomes a ‚Äúgod broadcaster‚Äù that knows about every consumer in the system.</li>
  <li><strong>Hard Runtime Behavior</strong>: Managing subscriptions becomes messy. If a UI component opens, we have to remember to set the <code class="language-plaintext highlighter-rouge">ui</code> pointer. If it closes, we have to remember to null it out or risk dereferencing a dangling pointer.</li>
  <li><strong>Polling Temptation</strong>: To avoid coupling, some might be tempted to have consumers poll <code class="language-plaintext highlighter-rouge">PriceFeed.get_latest()</code>, which wastes CPU and adds latency.</li>
</ol>

<h4 id="what-we-want-instead">What we want instead</h4>
<p>A design where:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">PriceFeed</code> only knows an Observer interface (not UI/Alerts/Risk)</li>
  <li>Any consumer can attach/detach at runtime</li>
  <li>On each tick, PriceFeed just says: notifyAll(tick)</li>
  <li>New consumers can be added without modifying PriceFeed</li>
</ul>

<h3 id="the-observer-pattern"><strong>The ‚ÄúObserver Pattern‚Äù</strong></h3>

<p>The Observer Pattern defines a one-to-many dependency between objects. When the state of one object (the Subject) changes, all its dependents (Observers) are notified and updated automatically. This pattern promotes loose coupling and adheres to the Open-Closed Principle. In our case -</p>
<ul>
  <li>The <code class="language-plaintext highlighter-rouge">PriceFeed</code> is the <strong>Subject</strong>. A subject is an object having a state and a list of observers that are interested in changes to that state.</li>
  <li>Each consumer (UI, AlertEngine, RiskMonitor, Logger) implements the <strong>Observer interface</strong> through which they receive updates from the Subject.</li>
  <li>The Subject maintains a list of its observers and notifies them of any state changes, usually by calling one of their methods (e.g., <code class="language-plaintext highlighter-rouge">update()</code>).</li>
</ul>

<h4 id="design-strategy-decouple-the-broadcaster-from-the-consumers"><strong>Design Strategy: Decouple the Broadcaster from the Consumers</strong></h4>

<ul>
  <li><strong>Freeze the Broadcaster</strong>: <code class="language-plaintext highlighter-rouge">PriceFeed</code> (the Subject) should only know that it has a list of ‚Äúthings that want to listen‚Äù. Beyond that, it should not care about the specific types of consumers or how they react to updates. It just needs to know how to notify them.</li>
  <li><strong>Define a Contract</strong>: Create an <code class="language-plaintext highlighter-rouge">IObserver</code> interface with a single method like <code class="language-plaintext highlighter-rouge">onUpdate(tick)</code>. This <code class="language-plaintext highlighter-rouge">IObserver</code> interface is the contract that all consumers must implement to receive updates. The <code class="language-plaintext highlighter-rouge">PriceFeed</code> will only interact with this interface, not caring about the concrete consumer types.</li>
  <li><strong>Program to Interface</strong>: <code class="language-plaintext highlighter-rouge">PriceFeed</code> stores a list of <code class="language-plaintext highlighter-rouge">IObserver*</code>. It doesn‚Äôt care if the pointer is a UI, a Logger, or a Risk Monitor. All it knows is that it can call <code class="language-plaintext highlighter-rouge">onUpdate(tick)</code> on each observer when a new tick arrives. This allows us to add new consumer types in the future without modifying <code class="language-plaintext highlighter-rouge">PriceFeed</code>. The new consumer just needs to implement the <code class="language-plaintext highlighter-rouge">IObserver</code> interface and register itself with the <code class="language-plaintext highlighter-rouge">PriceFeed</code>.</li>
  <li><strong>Runtime Management</strong>: Provide <code class="language-plaintext highlighter-rouge">attach()</code> and <code class="language-plaintext highlighter-rouge">detach()</code> methods to manage the listener list dynamically. These methods allow consumers to subscribe and unsubscribe at runtime without affecting the <code class="language-plaintext highlighter-rouge">PriceFeed</code> logic.</li>
</ul>

<h4 id="components-involved-and-their-responsibilities"><strong>Components involved and their responsibilities</strong></h4>

<ul>
  <li>
    <p><strong>Subject Interface <code class="language-plaintext highlighter-rouge">IPriceSubject</code></strong> - Purpose of <code class="language-plaintext highlighter-rouge">IPriceSubject</code> is to define the contract for the Subject, ensuring that any concrete implementation (like <code class="language-plaintext highlighter-rouge">PriceFeed</code>) adheres to the expected behavior of managing observers and notifications. This abstraction allows for flexibility in how the Subject is implemented while maintaining a consistent interface for observers to interact with. It defines the essential methods (e.g., <code class="language-plaintext highlighter-rouge">attach()</code>, <code class="language-plaintext highlighter-rouge">detach()</code>, <code class="language-plaintext highlighter-rouge">notify()</code>) for attaching, detaching, and notifying observers, which are crucial for the Observer Pattern to function effectively. By programming to this interface, we can easily swap out different Subject implementations without affecting the observers, as long as they adhere to the same contract.</p>
  </li>
  <li><strong>Subject <code class="language-plaintext highlighter-rouge">PriceFeed</code></strong>: Owns the state (latest tick) and the list of observers. It provides an API for attaching/detaching and triggers the notification loop. It is the ‚Äúbroadcaster‚Äù that doesn‚Äôt care about who is listening, just that it needs to notify them.
    <ul>
      <li>
        <p>The <code class="language-plaintext highlighter-rouge">onNewTick()</code> method is the entry point for new data, and it simply calls <code class="language-plaintext highlighter-rouge">notify()</code> to broadcast to all observers. <code class="language-plaintext highlighter-rouge">notify()</code> iterates through the list of observers and calls their <code class="language-plaintext highlighter-rouge">onUpdate(tick)</code> method, ensuring that all registered observers receive the latest tick information.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">attach()</code> and <code class="language-plaintext highlighter-rouge">detach()</code> manage the list of observers, allowing for dynamic subscription.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Observer Interface (IPriceObserver)</strong>: Defines the contract for observers. Any consumer that wants to receive updates must implement this interface. It ensures that all observers have a common method (<code class="language-plaintext highlighter-rouge">onUpdate(tick)</code>) that the Subject can call to notify them of changes. This interface abstracts away the specific implementation details of the observers, allowing the Subject to interact with them in a uniform way. By adhering to this interface, new consumer types can be added without modifying the Subject, as they will simply implement the required method to receive updates.</p>
  </li>
  <li>
    <p><strong>Concrete Observers (UI, AlertEngine, Logger)</strong>: Each consumer implements its own reaction to the price change. For example, the UI might update a display, the AlertEngine might check if certain conditions are met to trigger alerts, and the Logger might write the tick to a file or database. Each observer is responsible for its own logic in response to the updates it receives from the Subject.</p>
  </li>
  <li><strong>Client</strong>: Connects specific consumers to the <code class="language-plaintext highlighter-rouge">PriceFeed</code> at runtime. The client is responsible for creating instances of the concrete observers and attaching them to the <code class="language-plaintext highlighter-rouge">PriceFeed</code>. This allows for flexibility in how the system is configured at runtime, as different observers can be attached or detached based on user interactions or other conditions.</li>
</ul>

<h3 id="capture-the-design-visually-uml"><strong>Capture the design visually (UML)</strong></h3>

<pre><code class="language-mermaid">classDiagram
direction LR

class IPriceObserver {
    &lt;&lt;interface&gt;&gt;
    +onUpdate(tick)
}

class IPriceSubject {
    &lt;&lt;interface&gt;&gt;
    +attach(observer)
    +detach(observer)
    +notify(tick)
}

class PriceFeed {
    -observers
    +attach(observer)
    +detach(observer)
    +onNewTick(symbol, price, timestamp)
}

class UiTickerDisplay {
    +onUpdate(tick)
}

class AlertEngine {
    +onUpdate(tick)
}

class AuditLogger {
    +onUpdate(tick)
}

IPriceSubject &lt;|.. PriceFeed
PriceFeed ..&gt; IPriceObserver
IPriceObserver &lt;|.. UiTickerDisplay
IPriceObserver &lt;|.. AlertEngine
IPriceObserver &lt;|.. AuditLogger

style IPriceObserver fill:#f2f2f2,stroke:#333,stroke-width:2px
style IPriceSubject fill:#f2f2f2,stroke:#333,stroke-width:2px
style PriceFeed fill:#e1f5fe,stroke:#01579b,stroke-width:2px
style UiTickerDisplay fill:#fff3e0,stroke:#e65100,stroke-width:2px
style AlertEngine fill:#fff3e0,stroke:#e65100,stroke-width:2px
style AuditLogger fill:#fff3e0,stroke:#e65100,stroke-width:2px
</code></pre>

<h3 id="c-implementation"><strong>C++ Implementation</strong></h3>

<p>First, we define the domain model for a stock tick, which includes the symbol, price, and timestamp.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Domain Model: The data being observed</span>
<span class="k">struct</span> <span class="nc">Tick</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">symbol</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">price</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="p">;</span> <span class="c1">// epoch time in milliseconds</span>
<span class="p">};</span>
</code></pre></div></div>
<p>Then, we define the Observer interface, which declares the <code class="language-plaintext highlighter-rouge">onUpdate</code> method that all observers must implement to receive updates from the Subject.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Observer Interface (The Contract)</span>
<span class="k">class</span> <span class="nc">IPriceObserver</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IPriceObserver</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">onUpdate</span><span class="p">(</span><span class="k">const</span> <span class="n">Tick</span><span class="o">&amp;</span> <span class="n">tick</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>We, then define the Subject interface, which declares methods for attaching, detaching, and notifying observers. This interface allows for different implementations of the Subject while maintaining a consistent way for observers to interact with it.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Subject Interface (The Broadcaster)</span>
<span class="k">class</span> <span class="nc">IPriceSubject</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IPriceSubject</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">attach</span><span class="p">(</span><span class="n">IPriceObserver</span><span class="o">*</span> <span class="n">observer</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">detach</span><span class="p">(</span><span class="n">IPriceObserver</span><span class="o">*</span> <span class="n">observer</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">notify</span><span class="p">(</span><span class="k">const</span> <span class="n">Tick</span><span class="o">&amp;</span> <span class="n">tick</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>We then implement the <code class="language-plaintext highlighter-rouge">PriceFeed</code> class, which is a concrete implementation of the <code class="language-plaintext highlighter-rouge">IPriceSubject</code> interface. It maintains a list of observers and implements the logic for attaching, detaching, and notifying them when a new tick arrives.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Concrete Subject</span>
<span class="k">class</span> <span class="nc">PriceFeed</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IPriceSubject</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IPriceObserver</span><span class="o">*&gt;</span> <span class="n">observers</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="c1">// start receiving ticks from the market data source (simulated here)</span>
    <span class="kt">void</span> <span class="n">attach</span><span class="p">(</span><span class="n">IPriceObserver</span><span class="o">*</span> <span class="n">observer</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">observers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">observer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Detach an observer by removing it from the list, it no longer receives updates</span>
    <span class="kt">void</span> <span class="nf">detach</span><span class="p">(</span><span class="n">IPriceObserver</span><span class="o">*</span> <span class="n">observer</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">observers</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">observers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">observers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">observer</span><span class="p">),</span> <span class="n">observers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// Notify all observers about the new tick</span>
    <span class="kt">void</span> <span class="nf">notify</span><span class="p">(</span><span class="k">const</span> <span class="n">Tick</span><span class="o">&amp;</span> <span class="n">tick</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">obs</span> <span class="o">:</span> <span class="n">observers</span><span class="p">)</span> <span class="n">obs</span><span class="o">-&gt;</span><span class="n">onUpdate</span><span class="p">(</span><span class="n">tick</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// External event trigger</span>
    <span class="kt">void</span> <span class="nf">onNewTick</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">symbol</span><span class="p">,</span> <span class="kt">double</span> <span class="n">price</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Tick</span> <span class="n">tick</span><span class="p">{</span><span class="n">symbol</span><span class="p">,</span> <span class="n">price</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">};</span>

        <span class="c1">// Market data arrives here, some processing can be done if needed (e.g., filtering, enrichment)</span>

        <span class="c1">// Notify all observers about the new tick</span>
        <span class="n">notify</span><span class="p">(</span><span class="n">tick</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Then come the concrete observers, which implement the <code class="language-plaintext highlighter-rouge">IPriceObserver</code> interface. Each observer defines its own logic for handling updates from the <code class="language-plaintext highlighter-rouge">PriceFeed</code>. For example, the <code class="language-plaintext highlighter-rouge">UiTickerDisplay</code> updates the UI, the <code class="language-plaintext highlighter-rouge">AlertEngine</code> checks for alert conditions, and the <code class="language-plaintext highlighter-rouge">AuditLogger</code> logs the tick information.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Concrete Observers (The Consumers)</span>
<span class="k">class</span> <span class="nc">UiTickerDisplay</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IPriceObserver</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">onUpdate</span><span class="p">(</span><span class="k">const</span> <span class="n">Tick</span><span class="o">&amp;</span> <span class="n">tick</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[UI Ticker] "</span> <span class="o">&lt;&lt;</span> <span class="n">tick</span><span class="p">.</span><span class="n">symbol</span> <span class="o">&lt;&lt;</span> <span class="s">" is now $"</span> <span class="o">&lt;&lt;</span> <span class="n">tick</span><span class="p">.</span><span class="n">price</span> <span class="o">&lt;&lt;</span> <span class="s">" (Time: "</span> <span class="o">&lt;&lt;</span> <span class="n">tick</span><span class="p">.</span><span class="n">timestamp</span> <span class="o">&lt;&lt;</span> <span class="s">")</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AlertEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IPriceObserver</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">onUpdate</span><span class="p">(</span><span class="k">const</span> <span class="n">Tick</span><span class="o">&amp;</span> <span class="n">tick</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tick</span><span class="p">.</span><span class="n">price</span> <span class="o">&gt;</span> <span class="mf">150.0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Alert] "</span> <span class="o">&lt;&lt;</span> <span class="n">tick</span><span class="p">.</span><span class="n">symbol</span> <span class="o">&lt;&lt;</span> <span class="s">" crossed $150 threshold!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AuditLogger</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IPriceObserver</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">onUpdate</span><span class="p">(</span><span class="k">const</span> <span class="n">Tick</span><span class="o">&amp;</span> <span class="n">tick</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Audit] Logged tick for "</span> <span class="o">&lt;&lt;</span> <span class="n">tick</span><span class="p">.</span><span class="n">symbol</span> <span class="o">&lt;&lt;</span> <span class="s">" at $"</span> <span class="o">&lt;&lt;</span> <span class="n">tick</span><span class="p">.</span><span class="n">price</span> <span class="o">&lt;&lt;</span> <span class="s">" @ "</span> <span class="o">&lt;&lt;</span> <span class="n">tick</span><span class="p">.</span><span class="n">timestamp</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Finally, we have the client code that wires everything together. It creates an instance of <code class="language-plaintext highlighter-rouge">PriceFeed</code>, attaches various observers to it, and simulates incoming ticks to demonstrate how the observers react to updates.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Client: Wiring it all together</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">PriceFeed</span> <span class="n">nasdaqFeed</span><span class="p">;</span>

    <span class="n">UiTickerDisplay</span> <span class="n">ui</span><span class="p">;</span>
    <span class="n">AlertEngine</span> <span class="n">alerts</span><span class="p">;</span>
    <span class="n">AuditLogger</span> <span class="n">logger</span><span class="p">;</span>

    <span class="c1">// Attach consumers at runtime</span>
    <span class="n">nasdaqFeed</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="p">);</span>
    <span class="n">nasdaqFeed</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alerts</span><span class="p">);</span>
    <span class="n">nasdaqFeed</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logger</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"--- Tick 1 ---</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">nasdaqFeed</span><span class="p">.</span><span class="n">onNewTick</span><span class="p">(</span><span class="s">"AAPL"</span><span class="p">,</span> <span class="mf">145.20</span><span class="p">,</span> <span class="mi">1707810000000LL</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">--- Tick 2 (Price spike) ---</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">nasdaqFeed</span><span class="p">.</span><span class="n">onNewTick</span><span class="p">(</span><span class="s">"AAPL"</span><span class="p">,</span> <span class="mf">152.45</span><span class="p">,</span> <span class="mi">1707810001000LL</span><span class="p">);</span>

    <span class="c1">// Dynamic detach</span>
    <span class="n">nasdaqFeed</span><span class="p">.</span><span class="n">detach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">--- Tick 3 (UI closed) ---</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">nasdaqFeed</span><span class="p">.</span><span class="n">onNewTick</span><span class="p">(</span><span class="s">"TSLA"</span><span class="p">,</span> <span class="mf">680.00</span><span class="p">,</span> <span class="mi">1707810002000LL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="conclusion"><strong>Conclusion</strong></h3>
<p>The Observer Pattern allows us to keep the <code class="language-plaintext highlighter-rouge">PriceFeed</code> class decoupled from the specific consumers. The <code class="language-plaintext highlighter-rouge">PriceFeed</code> only knows about the <code class="language-plaintext highlighter-rouge">IPriceObserver</code> interface, and any consumer that implements this interface can subscribe to receive updates. This design adheres to the Open-Closed Principle, as we can add new consumer types without modifying the <code class="language-plaintext highlighter-rouge">PriceFeed</code> code. The dynamic attach/detach functionality also allows for flexible runtime behavior, making it easy to manage which consumers are active at any given time.</p>

                </div>
            </article>
        </div>
    </main>

    
    <div style="text-align:center; font-size:1.2rem; margin:2rem 0;">
        <strong>You made it to the end! Thanks for reading ‚ù§Ô∏è</strong><br>
        <span style="font-size:0.95rem;">If you liked this, share your thoughts on my <a
                href="https://www.linkedin.com/in/onkarnm/" target="_blank"
                style="color:#0A66C2; text-decoration:none; font-weight:500;">LinkedIn page</a> ‚Äî I'd love to hear from
            you!</span>
    </div>
    

    <!-- Newsletter subscription disabled -->
    <!-- <div style="display:flex;justify-content:center;margin:0.25rem 0;">
        <!-- Inline ‚ÄúSubscribe‚Äù box -->
<!-- <span style="white-space:nowrap;">
    üöÄ <strong>Level-up your dev skills‚Äîget future articles in your inbox!</strong>
    <form action="https://formspree.io/f/xrbkplpp" method="POST"
        style="display:inline-flex;gap:.5rem;vertical-align:middle;margin-left:.75rem">
        <input type="email" name="email" required placeholder="Enter email"
            style="padding:.4rem .6rem;border:1px solid #ccc;border-radius:4px;max-width:240px;width:100%">
        <button type="submit"
            style="padding:.45rem .9rem;background:#007acc;color:#fff;border:none;border-radius:4px;cursor:pointer">
            Notify&nbsp;Me&nbsp;üì¨
        </button>
    </form>
</span> -->

<span class="subscribe-inline" style="display:none;">
    <strong>üöÄ Get new articles straight to your inbox!</strong>

    <form action="https://formspree.io/f/xrbkplpp" method="POST"
        style="display:inline-flex;gap:.5rem;vertical-align:middle">
        <input type="email" name="email" required placeholder="Enter email">
        <!-- <button type="submit">Notify Me üì¨</button> -->
        <button type="submit" style="white-space: nowrap;">Notify Me üì¨</button>

    </form>
</span>

<!-- Stay sharp‚Äî‚Äîget new articles straight to your inbox!
Level-up your dev skills - get new articles in your inbox! -->
    </div> -->

    <footer class="site-footer">
        <div class="wrapper">
            <div class="footer-col-wrapper">
                <div class="footer-col">
                    <p>&copy; 2026 Hack. Crash. Transcend.. All rights reserved.</p>
                </div>
            </div>
        </div>
    </footer>

</body>

</html>