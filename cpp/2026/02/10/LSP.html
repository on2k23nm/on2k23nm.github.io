<!DOCTYPE html>
<html lang=" en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Liskov Substitution Principle (LSP)</title>
    
    <meta name="description" content="Understanding the Liskov Substitution Principle (LSP) and its role in creating robust, substitutable software components, with examples in C++.">
    

    <link rel="canonical" href="https://on2k23nm.github.io/cpp/2026/02/10/LSP.html">

    <link rel="shortcut icon" href="/favicon.ico">

    <meta property="og:title" content="Liskov Substitution Principle (LSP)">
    <meta property="og:description" content="Understanding the Liskov Substitution Principle (LSP) and its role in creating robust, substitutable software components, with examples in C++.">
    <meta property="og:url" content="https://on2k23nm.github.io/cpp/2026/02/10/LSP.html">
    <meta property="og:site_name" content="Hack. Crash. Transcend."><meta property="og:type" content="article">
    <meta property="article:published_time" content="2026-02-10T00:00:03+05:30"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Liskov Substitution Principle (LSP)">
    <meta name="twitter:description" content="Understanding the Liskov Substitution Principle (LSP) and its role in creating robust, substitutable software components, with examples in C++."><link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/subscription.css">

    <!-- Your stylesheet -->
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/subscription.css">

    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4252008174002764"
        crossorigin="anonymous"></script>

    <meta name="google-site-verification" content="H0Tf6h_kdL03qvRv7KtC4i456PObcGwDPCxeiKFoll4" />

    
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    

    

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://on2k23nm.github.io/cpp/2026/02/10/LSP.html"
      },
      "headline": "Liskov Substitution Principle (LSP)",
      
      "datePublished": "2026-02-10T00:00:03+05:30",
      "dateModified": "2026-02-10T00:00:03+05:30",
      "author": {
        "@type": "Person",
        "name": "Your Name"
      },
       "publisher": {
        "@type": "Organization",
        "name": "Hack. Crash. Transcend.",
        "logo": {
          "@type": "ImageObject",
          "url": "https://on2k23nm.github.io/assets/images/logo.png"
        }
      },
      "description": "Understanding the Liskov Substitution Principle (LSP) and its role in creating robust, substitutable software components, with examples in C++."
      
    }
    </script>

</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-DTMB098MDX"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-DTMB098MDX');
</script>

<body>
    <header class="site-header">
        <div class="wrapper">
            <a class="site-title" href="/">Hack. Crash. Transcend.</a>
            <nav class="site-nav">
  <a class="page-link" href="/">Home</a>
  <a class="page-link" href="/about/">About</a>
</nav>

        </div>
    </header>

    <main class="page-content" aria-label="Content">
        <div class="wrapper">
            <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
                <header class="post-header">
                    <h1 class="post-title" itemprop="name headline">Liskov Substitution Principle (LSP)</h1>

                    <p class="post-meta">
                        <time datetime="2026-02-10T00:00:03+05:30" itemprop="datePublished">
                            üìÖ February 10, 2026
                        </time>
                        &nbsp;
                        ‚è±Ô∏è 18-minute read
                    </p>
                </header>

                <!-- 
                <div class="post-tags">
                    
                    <span class="tag">cpp-core</span>
                    
                    <span class="tag">design-patterns</span>
                    
                    <span class="tag">solid</span>
                    
                    <span class="tag">lsp</span>
                    
                </div>
                 -->
                
                <div class="post-tags">
                    <a class="tag" href="/tags/cpp-core">cpp-core</a>
                    <a class="tag" href="/tags/design-patterns">design-patterns</a>
                    <a class="tag" href="/tags/solid">solid</a>
                    <a class="tag" href="/tags/lsp">lsp</a>
                    
                </div>
                
                <div class="post-content" itemprop="articleBody">
                    <p>Here I discuss the <strong>Liskov Substitution Principle</strong>. As the name suggests, it is about <strong>substitutability</strong>. The reference for this discussion is taken from the wonderful lecture <em><a href="https://youtu.be/Ntraj80qN2k?si=iOcT6e4pdMoBCwNz&amp;t=1857">Breaking Dependencies: The SOLID Principles</a> by Klaus Iglberger at CppCon 2020</em>.</p>

<p>To explain it, let‚Äôs start with the original statement by Barbara Liskov, ‚ÄúData Abstraction and Hierarchy‚Äù (1987):</p>

<p><em>What is wanted here is something like the following substitution property: If for each object $o_1$ of type $S$ there is an object $o_2$ of type $T$ such that for all programs $P$ defined in terms of $T$, the behavior of $P$ is unchanged when $o_1$ is substituted for $o_2$, then $S$ is a subtype of $T$.</em>,</p>

<p>This statement is very concrete and very accurate for a mathematician. For everyone else, a simplified form is often sufficient, even though it is nowhere close to being as accurate as the original statement:</p>

<p><em>Subtypes must be substitutable for their base types.</em></p>

<p>Initially, it might seem that this is only about inheritance hierarchies. An example later shows that this is not necessarily just about inheritance hierarchies. Intuitively, it is about <strong>behavioral subtyping</strong>, which is what the simplified ‚Äúis-a‚Äù relationship refers to in practice: there is an expectation on some type, and those expectations should be fulfilled by anything that claims to be a subtype ‚Äî either a concrete type fulfilling a template parameter‚Äôs requirements or a derived class implementing a base class interface.</p>

<p><strong>Behavioral subtyping</strong> (aka the ‚Äúis-a‚Äù relationship) includes these rules:</p>

<table>
  <thead>
    <tr>
      <th>Rule</th>
      <th>Simple definition</th>
      <th>Practical example (fixed)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Method arguments must not be narrowed</strong> <em>(Contravariance of method arguments)</em></td>
      <td>An override must accept parameters that are the <em>same type or more general</em> than the base method.</td>
      <td>Base: <code class="language-plaintext highlighter-rouge">void drive(Vehicle v)</code><br />Derived override: <code class="language-plaintext highlighter-rouge">void drive(Vehicle v)</code> or <code class="language-plaintext highlighter-rouge">void drive(Object o)</code> - <em>good</em><br />Derived override: <code class="language-plaintext highlighter-rouge">void drive(Sedan s)</code>- <em>bad: strengthens what caller must provide</em></td>
    </tr>
    <tr>
      <td><strong>Return types may be narrowed</strong><br /><em>(Covariance of return types)</em></td>
      <td>An override may return a type that is the <em>same or more specific</em> than the base method.</td>
      <td>Base: <code class="language-plaintext highlighter-rouge">Vehicle* make()</code><br />Derived: <code class="language-plaintext highlighter-rouge">Tesla* make()</code> - <em>good</em><em>(C++: covariance works for pointers/references to class types)</em></td>
    </tr>
    <tr>
      <td><strong>Preconditions cannot be strengthened</strong></td>
      <td>The subtype cannot require <em>more</em> from the caller than the base contract.</td>
      <td>Base accepts any integer. Derived cannot suddenly accept <em>only positive</em> integers.</td>
    </tr>
    <tr>
      <td><strong>Postconditions cannot be weakened</strong></td>
      <td>The subtype cannot guarantee <em>less</em> than what the base contract promises.</td>
      <td>Base guarantees ‚Äúfile is saved‚Äù. Derived cannot say ‚Äúmaybe saved, maybe not‚Äù.</td>
    </tr>
    <tr>
      <td><strong>Invariants must be preserved</strong></td>
      <td>Properties that must always hold for the base type must <em>remain true</em> for the subtype.</td>
      <td>If base expects width/height to be independently settable, a subtype must not break that (classic Rectangle/Square issue).</td>
    </tr>
  </tbody>
</table>

<p>If these hold, substitutability can work pretty well.</p>

<p>The Liskov Substitution Principle is ultimately about <strong>behavioral compatibility</strong>. If a type <code class="language-plaintext highlighter-rouge">Derived</code> is a subtype of <code class="language-plaintext highlighter-rouge">Base</code>, then code written against <code class="language-plaintext highlighter-rouge">Base</code> should continue to work correctly when you pass a <code class="language-plaintext highlighter-rouge">Derived</code>. That only holds when the derived type preserves the <strong>expectations / contract</strong> implied by the base type‚Äôs interface.</p>

<p>To internalize this, let‚Äôs look at a classic textbook example that often leads to a design trap: the relationship between a <strong>Square</strong> and a <strong>Rectangle</strong>. In geometry, we are taught that ‚Äúa square is a rectangle,‚Äù which intuitively suggests an inheritance relationship.</p>

<p>However, when we translate this into software, we must decide which direction the inheritance should go. There are two primary design options to consider:</p>

<h2 id="option-a-rectangle-derives-from-square">Option A: <code class="language-plaintext highlighter-rouge">Rectangle</code> derives from <code class="language-plaintext highlighter-rouge">Square</code></h2>

<p>In this design, we begin with a <code class="language-plaintext highlighter-rouge">Square</code>. A square stores a single dimension (<code class="language-plaintext highlighter-rouge">width</code>). It exposes a virtual setter <code class="language-plaintext highlighter-rouge">setWidth(double)</code> and a virtual <code class="language-plaintext highlighter-rouge">getArea()</code>. The area computation for a square is based on the single side length, so <code class="language-plaintext highlighter-rouge">getArea()</code> returns <code class="language-plaintext highlighter-rouge">width * width</code>. (Other functions may exist, but these are the important ones here.)</p>

<p>Then we derive <code class="language-plaintext highlighter-rouge">Rectangle</code> from <code class="language-plaintext highlighter-rouge">Square</code>. A rectangle needs one more dimension (<code class="language-plaintext highlighter-rouge">height</code>), so the derived class introduces a second data member and adds a new setter <code class="language-plaintext highlighter-rouge">setHeight(double)</code>. Since <code class="language-plaintext highlighter-rouge">getArea()</code> is virtual, the rectangle can override it and compute the correct rectangle area as <code class="language-plaintext highlighter-rouge">width * height</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//***** Option A *****</span>

<span class="k">class</span> <span class="nc">Square</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">setWidth</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">getArea</span><span class="p">();</span>
    <span class="c1">// ...</span>
<span class="nl">private:</span>
    <span class="kt">double</span> <span class="n">width</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Rectangle</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">Square</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">setHeight</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
    <span class="c1">// ...</span>
<span class="nl">private:</span>
    <span class="kt">double</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This looks like a clean ‚Äúextension‚Äù: the derived type adds a new data member and new behavior.</p>

<h2 id="option-b-square-derives-from-rectangle">Option B: <code class="language-plaintext highlighter-rouge">Square</code> derives from <code class="language-plaintext highlighter-rouge">Rectangle</code></h2>

<p>In this design, we begin with a <code class="language-plaintext highlighter-rouge">Rectangle</code>. A rectangle stores two dimensions (<code class="language-plaintext highlighter-rouge">width</code> and <code class="language-plaintext highlighter-rouge">height</code>). It has two setters <code class="language-plaintext highlighter-rouge">setWidth(double)</code> and <code class="language-plaintext highlighter-rouge">setHeight(double)</code> and an area function <code class="language-plaintext highlighter-rouge">getArea()</code> implemented as <code class="language-plaintext highlighter-rouge">width * height</code>. (Again, other functions may exist, but these are what matters here.)</p>

<p>Then we derive <code class="language-plaintext highlighter-rouge">Square</code> from <code class="language-plaintext highlighter-rouge">Rectangle</code>. The key tension is that a square has only one side length, but the base class interface allows width and height to be set independently. To preserve the square‚Äôs invariant (equal sides), the derived class overrides both virtual setters so that <strong>either setter updates both data members</strong>: calling <code class="language-plaintext highlighter-rouge">setWidth</code> sets both <code class="language-plaintext highlighter-rouge">width</code> and <code class="language-plaintext highlighter-rouge">height</code>, and calling <code class="language-plaintext highlighter-rouge">setHeight</code> also sets both.</p>

<p>With that, <code class="language-plaintext highlighter-rouge">getArea()</code> returns the correct square area because <code class="language-plaintext highlighter-rouge">width</code> and <code class="language-plaintext highlighter-rouge">height</code> are always equal. Overriding <code class="language-plaintext highlighter-rouge">getArea()</code> is optional.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//***** Option B *****</span>

<span class="k">class</span> <span class="nc">Rectangle</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">setWidth</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">setHeight</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">getArea</span><span class="p">();</span>
    <span class="c1">// ...</span>
<span class="nl">private:</span>
    <span class="kt">double</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Square</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">Rectangle</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="why-option-b-violates-lsp">Why Option B violates LSP</h3>

<p>The base type <code class="language-plaintext highlighter-rouge">Rectangle</code> comes with an expectation: <strong>width and height can be changed independently</strong>. Client code relying on a rectangle assumes that a call to <code class="language-plaintext highlighter-rouge">setHeight()</code> changes only the height, and a call to <code class="language-plaintext highlighter-rouge">setWidth()</code> changes only the width.</p>

<p>LSP says: if <code class="language-plaintext highlighter-rouge">Square</code> is a subtype of <code class="language-plaintext highlighter-rouge">Rectangle</code>, then any code that works with a <code class="language-plaintext highlighter-rouge">Rectangle</code> should still work correctly when you pass a <code class="language-plaintext highlighter-rouge">Square</code> instead. Concretely, that means whatever ‚Äúpromises‚Äù the <code class="language-plaintext highlighter-rouge">Rectangle</code> interface makes to its callers must remain true for <code class="language-plaintext highlighter-rouge">Square</code>.</p>

<p>Here, the <code class="language-plaintext highlighter-rouge">Rectangle</code> interface exposes two independent setters:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setWidth</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setHeight</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</code></pre></div></div>

<p>So the <em>natural contract</em> (expectation) that client code forms is:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">setWidth(w)</code> changes the <strong>width</strong> to <code class="language-plaintext highlighter-rouge">w</code> (and does not silently change height).</li>
  <li><code class="language-plaintext highlighter-rouge">setHeight(h)</code> changes the <strong>height</strong> to <code class="language-plaintext highlighter-rouge">h</code> (and does not silently change width).</li>
  <li>Therefore, after calling one setter, the other dimension should remain what it was.</li>
</ul>

<p>In short: <strong>Rectangle‚Äôs interface suggests independent control of width and height.</strong></p>

<p>But in the derived type <code class="language-plaintext highlighter-rouge">Square</code>, that is no longer true: calling either setter changes <strong>both</strong> dimensions. So code that treats a <code class="language-plaintext highlighter-rouge">Square</code> as a <code class="language-plaintext highlighter-rouge">Rectangle</code> can observe behavior that violates what is expected from a rectangle (for example, changing one dimension unexpectedly changes the other). This means <code class="language-plaintext highlighter-rouge">Square</code> does not behave like a <code class="language-plaintext highlighter-rouge">Rectangle</code> is expected to behave, so substitutability breaks ‚Äî therefore LSP is violated.</p>

<p>Mapping this back to the formal LSP rules:</p>

<table>
  <thead>
    <tr>
      <th>LSP rule</th>
      <th>Violated in Option B?</th>
      <th>Why (in terms of Option B‚Äôs <code class="language-plaintext highlighter-rouge">Rectangle</code> ‚Üí <code class="language-plaintext highlighter-rouge">Square</code>)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Contravariance of method arguments in a subtype</td>
      <td><strong>No</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Square</code> overrides <code class="language-plaintext highlighter-rouge">setWidth(double)</code> and <code class="language-plaintext highlighter-rouge">setHeight(double)</code> with the <strong>same parameter type</strong> (<code class="language-plaintext highlighter-rouge">double</code>). No ‚Äúwidening‚Äù/contravariant change of argument types happens.</td>
    </tr>
    <tr>
      <td>Covariance of return types in a subtype</td>
      <td><strong>No</strong></td>
      <td>Return types aren‚Äôt changed (<code class="language-plaintext highlighter-rouge">void</code> setters, <code class="language-plaintext highlighter-rouge">int getArea()</code>), so there is no covariance issue demonstrated.</td>
    </tr>
    <tr>
      <td>Preconditions cannot be strengthened in a subtype</td>
      <td><strong>No (not shown)</strong></td>
      <td>The Option B description does not introduce extra requirements like ‚Äúonly call setWidth if ‚Ä¶‚Äù. The problem shown is not about stronger input requirements; it‚Äôs about changed behavior.</td>
    </tr>
    <tr>
      <td>Postconditions cannot be weakened in a subtype</td>
      <td><strong>Yes</strong></td>
      <td>For <code class="language-plaintext highlighter-rouge">Rectangle</code>, the natural expectation is: <code class="language-plaintext highlighter-rouge">setWidth(w)</code> changes <strong>only width</strong>, and <code class="language-plaintext highlighter-rouge">setHeight(h)</code> changes <strong>only height</strong>. In <code class="language-plaintext highlighter-rouge">Square</code>, those postconditions are weakened/changed because each setter changes <strong>both</strong> width and height, so the base-type guarantee (‚Äúother dimension unchanged‚Äù) no longer holds.</td>
    </tr>
    <tr>
      <td>Invariants of the super type must be preserved in a subtype</td>
      <td><strong>Yes</strong></td>
      <td>The super type (<code class="language-plaintext highlighter-rouge">Rectangle</code>) implicitly allows the invariant ‚Äúwidth and height are independently settable‚Äù (they can differ and can be controlled separately). <code class="language-plaintext highlighter-rouge">Square</code> replaces that by enforcing <code class="language-plaintext highlighter-rouge">width == height</code>, so it does not preserve the rectangle‚Äôs behavioral invariant/expectation.</td>
    </tr>
  </tbody>
</table>

<h3 id="why-option-a-is-not-better-either">Why Option A is not better either</h3>

<p>The base type <strong>Square</strong> comes with an expectation: it models a shape with a <strong>single side length</strong>. Client code relying on a <code class="language-plaintext highlighter-rouge">Square</code> assumes that a call to <code class="language-plaintext highlighter-rouge">setWidth()</code> sets that one side length, and that <code class="language-plaintext highlighter-rouge">getArea()</code> computes the area in the ‚Äúsquare way‚Äù (based on that single width, i.e., <code class="language-plaintext highlighter-rouge">width * width</code>).</p>

<p>The key point of LSP is substitutability: if <code class="language-plaintext highlighter-rouge">Rectangle</code> is a subtype of <code class="language-plaintext highlighter-rouge">Square</code>, then any (client) code that works with a <code class="language-plaintext highlighter-rouge">Square</code> should still work correctly when you pass a <code class="language-plaintext highlighter-rouge">Rectangle</code> instead.</p>

<p>LSP says: <strong>if <code class="language-plaintext highlighter-rouge">Rectangle</code> is a subtype of <code class="language-plaintext highlighter-rouge">Square</code>, then any (client) code that works with a <code class="language-plaintext highlighter-rouge">Square</code> should still work correctly when you pass a <code class="language-plaintext highlighter-rouge">Rectangle</code> instead.</strong></p>

<p>Concretely, that means:</p>

<ul>
  <li>Whatever ‚Äúpromises‚Äù the <code class="language-plaintext highlighter-rouge">Square</code> interface makes to its callers/clients must remain true for <code class="language-plaintext highlighter-rouge">Rectangle</code>.</li>
  <li>Here, the <code class="language-plaintext highlighter-rouge">Square</code> interface exposes a single setter and an area computation based on that single dimension:</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setWidth</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="k">virtual</span> <span class="kt">int</span>  <span class="nf">getArea</span><span class="p">();</span>
</code></pre></div></div>

<p>So the natural contract (expectation) that client code forms is:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">setWidth(w)</code> changes the square‚Äôs side length to <code class="language-plaintext highlighter-rouge">w</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">getArea()</code> returns an area consistent with a square that has side length <code class="language-plaintext highlighter-rouge">w</code> (i.e., it behaves like <code class="language-plaintext highlighter-rouge">w * w</code>).</li>
  <li>There is no second independent dimension being tracked through the <code class="language-plaintext highlighter-rouge">Square</code> interface.</li>
</ul>

<p>In short: <strong>Square‚Äôs interface suggests a single-dimension (‚Äúone side length‚Äù) model.</strong></p>

<p>But in the derived type <strong>Rectangle</strong>, that is no longer true: a rectangle fundamentally needs a second dimension (<code class="language-plaintext highlighter-rouge">height</code>). Even if <code class="language-plaintext highlighter-rouge">setWidth(w)</code> still sets the width, the rectangle also has height, and the correct rectangle area is <code class="language-plaintext highlighter-rouge">width * height</code>. So <code class="language-plaintext highlighter-rouge">Rectangle</code> overrides <code class="language-plaintext highlighter-rouge">getArea()</code> to compute <code class="language-plaintext highlighter-rouge">width * height</code>.</p>

<p>This creates the same LSP problem as Option B, just with a different twist: code that treats a <code class="language-plaintext highlighter-rouge">Rectangle</code> as a <code class="language-plaintext highlighter-rouge">Square</code> can observe behavior that violates what is expected from a square. For example, after calling <code class="language-plaintext highlighter-rouge">setWidth(w)</code>, calling <code class="language-plaintext highlighter-rouge">getArea()</code> may depend on an additional dimension (<code class="language-plaintext highlighter-rouge">height</code>) that the <code class="language-plaintext highlighter-rouge">Square</code> interface never exposed or allowed the client to control. That means <code class="language-plaintext highlighter-rouge">Rectangle</code> does not behave like a <code class="language-plaintext highlighter-rouge">Square</code> is expected to behave, so substitutability breaks ‚Äî therefore LSP is violated.</p>

<p>Mapping this back to the formal LSP rules:</p>

<table>
  <thead>
    <tr>
      <th>LSP rule</th>
      <th>Violated in Option A?</th>
      <th>Why (in terms of Option A‚Äôs <code class="language-plaintext highlighter-rouge">Square</code> ‚Üí <code class="language-plaintext highlighter-rouge">Rectangle</code>)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Contravariance of method arguments in a subtype</td>
      <td><strong>No</strong></td>
      <td><code class="language-plaintext highlighter-rouge">Rectangle</code> does not override <code class="language-plaintext highlighter-rouge">Square::setWidth(double)</code> with a <em>wider</em> / contravariant parameter type. The parameter type stays <code class="language-plaintext highlighter-rouge">double</code> (and <code class="language-plaintext highlighter-rouge">setHeight(double)</code> is an additional method, not a contravariant override).</td>
    </tr>
    <tr>
      <td>Covariance of return types in a subtype</td>
      <td><strong>No</strong></td>
      <td>Return types aren‚Äôt changed (<code class="language-plaintext highlighter-rouge">int getArea()</code>, <code class="language-plaintext highlighter-rouge">void</code> setters), so there is no covariance issue demonstrated.</td>
    </tr>
    <tr>
      <td>Preconditions cannot be strengthened in a subtype</td>
      <td><strong>No (not shown)</strong></td>
      <td>The Option A description does not introduce extra call requirements like ‚Äúonly call <code class="language-plaintext highlighter-rouge">setWidth</code> if ‚Ä¶‚Äù. The problem shown is not about stronger input requirements; it is about changed behavior/expectations.</td>
    </tr>
    <tr>
      <td>Postconditions cannot be weakened in a subtype</td>
      <td><strong>Yes</strong></td>
      <td>For <code class="language-plaintext highlighter-rouge">Square</code>, the natural expectation is: after <code class="language-plaintext highlighter-rouge">setWidth(w)</code>, <code class="language-plaintext highlighter-rouge">getArea()</code> behaves like a square area based on that single side length (conceptually <code class="language-plaintext highlighter-rouge">w * w</code>). In <code class="language-plaintext highlighter-rouge">Rectangle</code>, <code class="language-plaintext highlighter-rouge">getArea()</code> is overridden to compute <code class="language-plaintext highlighter-rouge">width * height</code>, so after setting only width via the <code class="language-plaintext highlighter-rouge">Square</code> interface, the observed area can depend on another dimension (<code class="language-plaintext highlighter-rouge">height</code>) that the base interface did not expose/control. That means the base-type postcondition (area consistent with the ‚Äúsingle side length‚Äù model) no longer reliably holds.</td>
    </tr>
    <tr>
      <td>Invariants of the super type must be preserved in a subtype</td>
      <td><strong>Yes</strong></td>
      <td>The super type (<code class="language-plaintext highlighter-rouge">Square</code>) carries the invariant/meaning ‚Äúa single side length determines the shape.‚Äù <code class="language-plaintext highlighter-rouge">Rectangle</code> introduces a second independent dimension (<code class="language-plaintext highlighter-rouge">height</code>), so substituting a <code class="language-plaintext highlighter-rouge">Rectangle</code> where a <code class="language-plaintext highlighter-rouge">Square</code> is expected can violate that base-type invariant/expectation.</td>
    </tr>
  </tbody>
</table>

<h3 id="summary">Summary</h3>

<ul>
  <li><strong>Option B fails</strong> because <code class="language-plaintext highlighter-rouge">Square</code> cannot honor <code class="language-plaintext highlighter-rouge">Rectangle</code>‚Äôs ‚Äúindependent width/height setters‚Äù contract.</li>
  <li><strong>Option A fails</strong> because <code class="language-plaintext highlighter-rouge">Rectangle</code> cannot honor <code class="language-plaintext highlighter-rouge">Square</code>‚Äôs ‚Äúsingle side-length semantics‚Äù contract (area tied only to width as a square).</li>
</ul>

<p>Both options violate LSP, just in different ways.</p>

<h3 id="main-takeaway">Main takeaway</h3>

<p>The lesson here is not that inheritance is always wrong. The lesson is that inheritance can be <strong>misleadingly intuitive</strong> (especially when thinking in terms of math relationships), but in software design it depends entirely on the <strong>base type‚Äôs contract</strong>.</p>

<p><strong>Before inheriting, you must understand what clients of the base type are allowed to assume, and the derived type must preserve those assumptions.</strong></p>

<h2 id="stdcopy-through-the-lsp-lens"><code class="language-plaintext highlighter-rouge">std::copy</code> through the LSP lens</h2>

<p>The Liskov Substitution Principle (LSP) is about <strong>substitutability</strong>. If a piece of code is written assuming some expected type/behavior, then anything you provide in that role must behave as expected. If it does not, the code may break even though it ‚Äúlooks‚Äù type-correct.</p>

<p>For templates, this idea appears in a slightly different form. The ‚Äúbase type‚Äù is not a class in an inheritance hierarchy. Instead, the ‚Äúbase type‚Äù is the behavioral contract (often called a <em>concept</em>) that the template parameters are expected to satisfy.</p>

<h3 id="what-stdcopy-assumes">What <code class="language-plaintext highlighter-rouge">std::copy</code> assumes</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OutputIt</span> <span class="p">&gt;</span>
<span class="n">OutputIt</span> <span class="n">copy</span><span class="p">(</span> <span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">OutputIt</span> <span class="n">dest</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">,</span> <span class="o">++</span><span class="n">dest</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace std</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">std::copy(InputIt first, InputIt last, OutputIt dest)</code> relies on two expectations:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">InputIt</code> adheres to the required concept (behaves like an <strong>input iterator</strong>)</li>
  <li><code class="language-plaintext highlighter-rouge">OutputIt</code> adheres to the required concept (behaves like an <strong>output iterator</strong>)</li>
</ul>

<p>Here, ‚Äúrequired concept‚Äù means the set of operations and behaviors that the algorithm expects from the iterator types. These expectations are the contract the algorithm is written against. The algorithm will only work correctly if the types passed in really satisfy those behaviors.</p>

<h3 id="the-required-concept-stdcopy-expects">The ‚Äúrequired concept‚Äù <code class="language-plaintext highlighter-rouge">std::copy</code> expects</h3>

<h4 id="required-concept-for-inputit-input-iterator-behavior">Required concept for <code class="language-plaintext highlighter-rouge">InputIt</code> (input iterator behavior)</h4>
<p>Inside <code class="language-plaintext highlighter-rouge">std::copy</code>, the input iterator is used in three essential ways:</p>
<ol>
  <li><strong>Comparison:</strong> <code class="language-plaintext highlighter-rouge">first != last</code> - This must tell whether the input range is finished.</li>
  <li><strong>Increment:</strong> <code class="language-plaintext highlighter-rouge">++first</code> - This must move the iterator forward to the next element.</li>
  <li><strong>Read / dereference:</strong> <code class="language-plaintext highlighter-rouge">*first</code> - This must produce a readable value (something that can be copied).</li>
</ol>

<p>So the contract is: you can repeatedly compare, advance, and read elements until <code class="language-plaintext highlighter-rouge">first</code> reaches <code class="language-plaintext highlighter-rouge">last</code>.</p>

<h4 id="required-concept-for-outputit-output-iterator-behavior">Required concept for <code class="language-plaintext highlighter-rouge">OutputIt</code> (output iterator behavior)</h4>
<p>The output iterator is also used in two essential ways:</p>
<ol>
  <li><strong>Write through dereference:</strong> <code class="language-plaintext highlighter-rouge">*dest = value</code> - This must be valid, meaning <code class="language-plaintext highlighter-rouge">dest</code> must refer to a writable output position.</li>
  <li><strong>Increment:</strong> <code class="language-plaintext highlighter-rouge">++dest</code> - This must move to the next output position.</li>
</ol>

<p>So the contract is: <code class="language-plaintext highlighter-rouge">dest</code> points to a valid place you can write into, and advancing it produces the next valid place to write.</p>

<h3 id="what-the-loop-in-stdcopy-assumes-combined-contract">What the loop in <code class="language-plaintext highlighter-rouge">std::copy</code> assumes (combined contract)</h3>
<p>The core of the algorithm is:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">,</span> <span class="o">++</span><span class="n">dest</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>From this loop, the algorithm assumes that on each iteration:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">first != last</code> is meaningful,</li>
  <li><code class="language-plaintext highlighter-rouge">++first</code> and <code class="language-plaintext highlighter-rouge">++dest</code> are valid and move forward,</li>
  <li><code class="language-plaintext highlighter-rouge">*first</code> is readable,</li>
  <li><code class="language-plaintext highlighter-rouge">*dest = *first</code> is writable/assignable.</li>
</ul>

<p>If any of these expectations are not met, <code class="language-plaintext highlighter-rouge">std::copy</code> cannot be relied on to work. From an LSP perspective, this is a substitutability failure: a type is being used in a role (‚ÄúInputIt‚Äù or ‚ÄúOutputIt‚Äù) but does not fulfill the behavioral contract that role requires.</p>

<p>It is crucial to understand that <strong><code class="language-plaintext highlighter-rouge">std::copy</code> itself does not violate the contract</strong>‚Äîit is written assuming the contracts hold true. Instead, it is the <strong>caller</strong> (the client code) that either adheres to or violates the contract by providing iterators that do or do not meet the required behavior.</p>

<p>Here are concrete examples illustrating this:</p>

<h4 id="positive-caller-adheres-to-the-contract">Positive (caller adheres to the contract)</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">InputIt</code> contract holds: can compare/increment/read from <code class="language-plaintext highlighter-rouge">src</code> iterators.</li>
  <li><code class="language-plaintext highlighter-rouge">OutputIt</code> contract holds: <code class="language-plaintext highlighter-rouge">dst.begin()</code> points to real elements, so <code class="language-plaintext highlighter-rouge">*dest = value</code> is valid.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">src</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dst</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>               <span class="c1">// caller provides writable output range</span>
<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">dst</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> <span class="c1">// OK</span>
</code></pre></div></div>

<h4 id="negative-caller-breaks-the-outputit-contract">Negative (caller breaks the OutputIt contract)</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">OutputIt</code> contract does <strong>not</strong> hold: <code class="language-plaintext highlighter-rouge">dst.begin()</code> does not point to a valid writable element because <code class="language-plaintext highlighter-rouge">dst</code> has size 0.</li>
  <li><code class="language-plaintext highlighter-rouge">std::copy</code> will still try to do <code class="language-plaintext highlighter-rouge">*dest = *first</code>, but the caller did not provide a valid destination range ‚Üí invalid use.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">src</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dst</span><span class="p">;</span>                           <span class="c1">// caller does NOT provide writable output range</span>
<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">dst</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> <span class="c1">// invalid use</span>
</code></pre></div></div>

<h2 id="takeaway--guidelines">Takeaway / Guidelines</h2>

<p>After examining the Square/Rectangle example and the <code class="language-plaintext highlighter-rouge">std::copy</code> template example, here are the key guidelines to remember. The central idea behind LSP is not about how similar two types look by data fields, but whether the <strong>behavioral expectations</strong> created by an interface are preserved.</p>

<h3 id="guideline-1-inheritance-is-about-behavior-not-about-data">Guideline 1: Inheritance is about behavior, not about data</h3>

<p>Inheritance should be chosen based on <em>behavioral substitutability</em>, not because two types happen to share data members. As soon as a base class has a virtual function, that virtual function creates expectations about how objects of that type behave. That is the core point:</p>

<p><strong><em>inheritance is really about the behavior promised by the base type.</em></strong></p>

<h3 id="guideline-2-the-contract-of-base-types-must-be-adhered-to">Guideline 2: The contract of base types must be adhered to</h3>

<p>A base type comes with a contract (expectations). If a derived type claims to be a subtype, then it must fulfill those expectations. If the expectations are not fulfilled, the inheritance relationship can break in surprising and unexpected situations. So, whenever you inherit from a base class, the key check is:</p>

<p><strong><em>does the derived class still honor what users of the base class assume to be true ?</em></strong></p>

<h3 id="guideline-3-in-templates-adhere-to-the-required-concept">Guideline 3: In templates, adhere to the required concept</h3>

<p>For templated/generic code, the equivalent of ‚Äúbase class contract‚Äù is the ‚Äúrequired concept‚Äù. If a template expects a type that behaves like an input iterator or output iterator (as in <code class="language-plaintext highlighter-rouge">copy</code>), then whatever type you pass must actually behave that way.</p>

<p>So the guideline is:</p>

<p><em><strong>make sure the types you use in templated code adhere to the ‚Äúrequired concept‚Äù that the algorithm expects</strong></em></p>

<p>this plays the same role as fulfilling a base class contract in inheritance.</p>


                </div>
            </article>
        </div>
    </main>

    
    <div style="text-align:center; font-size:1.2rem; margin:2rem 0;">
        <strong>You made it to the end! Thanks for reading ‚ù§Ô∏è</strong><br>
        <span style="font-size:0.95rem;">If you liked this, share your thoughts on my <a
                href="https://www.linkedin.com/in/onkarnm/" target="_blank"
                style="color:#0A66C2; text-decoration:none; font-weight:500;">LinkedIn page</a> ‚Äî I'd love to hear from
            you!</span>
    </div>
    

    <!-- Newsletter subscription disabled -->
    <!-- <div style="display:flex;justify-content:center;margin:0.25rem 0;">
        <!-- Inline ‚ÄúSubscribe‚Äù box -->
<!-- <span style="white-space:nowrap;">
    üöÄ <strong>Level-up your dev skills‚Äîget future articles in your inbox!</strong>
    <form action="https://formspree.io/f/xrbkplpp" method="POST"
        style="display:inline-flex;gap:.5rem;vertical-align:middle;margin-left:.75rem">
        <input type="email" name="email" required placeholder="Enter email"
            style="padding:.4rem .6rem;border:1px solid #ccc;border-radius:4px;max-width:240px;width:100%">
        <button type="submit"
            style="padding:.45rem .9rem;background:#007acc;color:#fff;border:none;border-radius:4px;cursor:pointer">
            Notify&nbsp;Me&nbsp;üì¨
        </button>
    </form>
</span> -->

<span class="subscribe-inline" style="display:none;">
    <strong>üöÄ Get new articles straight to your inbox!</strong>

    <form action="https://formspree.io/f/xrbkplpp" method="POST"
        style="display:inline-flex;gap:.5rem;vertical-align:middle">
        <input type="email" name="email" required placeholder="Enter email">
        <!-- <button type="submit">Notify Me üì¨</button> -->
        <button type="submit" style="white-space: nowrap;">Notify Me üì¨</button>

    </form>
</span>

<!-- Stay sharp‚Äî‚Äîget new articles straight to your inbox!
Level-up your dev skills - get new articles in your inbox! -->
    </div> -->

    <footer class="site-footer">
        <div class="wrapper">
            <div class="footer-col-wrapper">
                <div class="footer-col">
                    <p>&copy; 2026 Hack. Crash. Transcend.. All rights reserved.</p>
                </div>
            </div>
        </div>
    </footer>

</body>

</html>